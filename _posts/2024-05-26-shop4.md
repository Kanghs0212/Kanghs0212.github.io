---
layout: single
title:  "스프링부트를 이용하여 쇼핑몰 구현하기 4장"
categories: shop
toc: true
toc_sticky: true
author_profile: false

---

본 게시글은 변구훈님의 스프링부트 쇼핑몰 프로젝트 with JPA 책을 참고하여
공부한 내용을 정리한 글입니다.

### 스프링 시큐리티
애플리케이션의 보안에서 가장 중요한 두 가지 영역은 '인증'과 '인가'다.
- 예를들어 댓글을 달기 위해서는 로그인이라는 '인증' 절차가 필요하다.
- '인가'는 인증 과정 이후에 일어난다. 만약 특정 URL이 관리자만 출입 가능하다면, 해당 URL을 눌렀을때 인가된 회원인지 검사를 한 후 접근한다.

#### 스프링 시큐리티 설정 추가
- 우선 pom.xml에 security 관련된 의존성을 추가 후 메이븐을 리로드해주자.

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

이제 우리는 이 security 의존성을 넣은것만으로도 모든 요청에 인증을 요구하게 된다.
한번 우리가 이전 3장에서 만들었던 ex03 사이트를 들어가보자.

<img src="/assets/images/blog/shop3/login.png" class="img-responsive" alt="">
그러면 다음과 같이 스프링 시큐리티가 지원하는 로그인 페이지로 이동한다.

- 아이디는 기본 user이며, 비밀번호는 어플리케이션 실행마다 콘솔창에 출력된다.

>Using generated security password: 2cf50b1d-f1ef-4382-9422-d2406df53fb0

- 따라서 위의 로그인창에 user와 2cf50b1d-f1ef-4382-9422-d2406df53fb0를 입력해주면 정상적으로 우리가 만든 페이지로 들어가지는걸 확인할수있다.

- 만약 localhost/logout으로 들어가보면 다음과 같이 로그아웃을 할건지 물어보는 화면이 나타난다.
- 로그아웃시 다시 로그인 요구 화면이 뜨게된다. 
<img src="/assets/images/blog/shop3/logout.png" class="img-responsive" alt="">

그러면 인증과 인가가 필요한 경우들은 무엇이 있을까?

1. 인증 필요 X : 상품 상세 페이지 조회
2. 인증 필요 O : 상품 주문
3. 관리자 권한 필요 : 상품 등록

#### 스프링 시큐리티 상세설정

먼저 com.shop에 config 패키지를 만들고 SecurityConfig 클래스를 만들어주자.

```java
import com.shop.service.MemberService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
@Configuration
@EnableWebSecurity
public class SecurityConfig{
    @Autowired
    MemberService memberService;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.formLogin((formLogin) -> formLogin
                        .usernameParameter("email") // 로그인 시 사용할 파라미터로 email 사용
                        .failureUrl("/members/login/error") // 로그인 실패시 이동할 페이지
                        .loginPage("/members/login") // 로그인 페이지 설정
                        .defaultSuccessUrl("/"))// 로그인 성공시 이동할 페이지)
                .logout((logout) -> logout
                        .logoutRequestMatcher(new AntPathRequestMatcher("/members/logout")) // 로그아웃 url 설정
                        .logoutSuccessUrl("/") // 로그아웃 성공 시 이동할 url
                        .invalidateHttpSession(true)) // 기존에 생성된 사용자 세션도 invalidateHttpSession 을 통해 삭제하도록 처리//
        ;

        http.authorizeRequests()
                .requestMatchers("/css/**", "/js/**", "/img/**").permitAll()
                .requestMatchers("/", "/members/**", "/item/**", "/images/**").permitAll()
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
        ;


        return http.build();
    }
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

여기서 몇가지 부분에 에러가 뜰것인데 이는 좀 이따 구현할것이니 일단은 지금은 넘어가도록 하자.

그다음은 constant 패키지에 Role이란 열거형(enum)을 생성해주자

```java
public enum Role {
    USER, ADMIN
}
```

이후 가입 화면으로부터 넘어오는 가입정보를 담은 dto를 생성해주자.
com.shop.dto.MemberFormDto.java를 생성후 다음 코드를 추가해주면 된다.

```java
package com.shop.dto;

import lombok.Getter;
import lombok.Setter;

@Getter @Setter
public class MemberFormDto {

    private String name;

    private String email;
    private String password;

    private String address;
}
```

그다음 com.show.entity 패키지에 Member.java 엔티티를 만들어주자,
관리할 회원 정보는 이름, 이메일, 비밀번호, 주소, 역할이다.

```java
package com.shop.entity;

import com.shop.constant.Role;
import com.shop.dto.MemberFormDto;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import org.springframework.security.crypto.password.PasswordEncoder;
import jakarta.persistence.*;

@Entity
@Table(name="member")
@Getter @Setter
@ToString
public class Member{

    @Id
    @Column(name="member_id")
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Long id;

    private String name;

    @Column(unique = true)
    // 회원은 이메일을 통해 유일하게 구분되므로 겹치지 않게 한다.
    private String email;

    private String password;

    private String address;

    @Enumerated(EnumType.STRING)
    // 자바의 enum타입을 엔티티의 속성으로 지정할 수 있다. Enum을 사용하게되면 순서가 저장되는데 enum의 순서가 바뀌는 경우가 생길 수 있으므로 EnumType.STRING으로 String저장한다.
    private Role role;

    public static Member createMember(MemberFormDto memberFormDto, PasswordEncoder passwordEncoder ) {
        Member member = new Member();
        member.setName(memberFormDto.getName());
        member.setEmail(memberFormDto.getEmail());
        member.setAddress(memberFormDto.getAddress());

        String password = passwordEncoder.encode(memberFormDto.getPassword());
        // 스프링시큐리티 설정 클래스에 등록한 BcryptPasswordEncoder Bean을 파라미터로 넘겨서 비밀번호를 암호화한다.
        member.setPassword(password);
        member.setRole(Role.ADMIN); // 계정 생성 시 권한을 Admin으로 고정

        return member;
    }
}
```


이후 com.shop.repository 패키지에 MemberRepository 인터페이스형을 만들어 Member 엔티티를 데이터베이스에 저장할 수 있도록 하자.

```java
import com.shop.entity.Member;
import org.springframework.data.jpa.repository.JpaRepository;

public interface MemberRepository extends JpaRepository<Member, Long>{
    Member findByEmail(String email);
    // 회원 가입시 중복된 회원이 있는지 확인하는 쿼리 메소드
}
```

이제 com.shop 패키지 아래에 service 패키지를 새로 만들어준 뒤 MemberService 클래스를 작성하자.

```java

import com.shop.entity.Member;
import com.shop.repository.MemberRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@Transactional
@RequiredArgsConstructor
public class MemberService{

    private final MemberRepository memberRepository;

    public Member saveMember(Member member){
        validateDuplicateMember(member); // 이미 가입된 회원인지를 검사
        return memberRepository.save(member); // 가입된 회원이 아니라면 데이터베이스에 저장
    }

    private void validateDuplicateMember(Member member){
        Member findMember = memberRepository.findByEmail(member.getEmail());
        if(findMember != null){
            throw new IllegalStateException("이미 가입된 회원입니다.");
        }
    }

}
```

- 이제 회원가입 기능이 정상적으로 동작하는지 테스트 코드를 작성해 검증해보자.
- test파일에 com.shop.service 패키지를 만들어 MemberServiceTest 클래스를 만들어주자

```java
import com.shop.dto.MemberFormDto;
import com.shop.entity.Member;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.test.context.TestPropertySource;
import org.springframework.transaction.annotation.Transactional;

import static org.junit.jupiter.api.Assertions.assertEquals;

@SpringBootTest
// 테스트 클래스에 선언할 경우 테스트 실행 후 롤백 처리됨. 이를 통해 같은 메소드를 반복적으로 테스트가능
@Transactional
@TestPropertySource(locations = "classpath:application-test.properties")
class MemberServiceTest {

    @Autowired
    MemberService memberService;

    @Autowired
    PasswordEncoder passwordEncoder;

    // 회원 정보를 입력한 Member 엔티티를 만드는 메소드를 작성
    public Member createMember(){
        MemberFormDto memberFormDto = new MemberFormDto();
        memberFormDto.setEmail("test@email.com");
        memberFormDto.setName("홍길동");
        memberFormDto.setAddress("서울시 마포구 합정동");
        memberFormDto.setPassword("1234");
        return Member.createMember(memberFormDto, passwordEncoder);
    }

    @Test
    @DisplayName("회원가입 테스트")
    // junit의 Assertions 클래스의 asserEquals 메소드를 이용하여 저장하려고 요청했던 값과 실제 저장된 데이터를 비교
    // 첫 번째 파라미터에는 기대 값, 두 번째 파라미터에는 실제로 저장된 값을 넣어줌
    public void saveMemberTest(){
        Member member = createMember();
        Member savedMember = memberService.saveMember(member);

        assertEquals(member.getEmail(), savedMember.getEmail());
        assertEquals(member.getName(), savedMember.getName());
        assertEquals(member.getAddress(), savedMember.getAddress());
        assertEquals(member.getPassword(), savedMember.getPassword());
        assertEquals(member.getRole(), savedMember.getRole());
    }

}
```
- 이제 테스트를 실행해볼시 정상적으로 회원가입이 이루어지는걸 확인할수있다.
- 이번에는 중복회원 가입 테스트를 해보자.
- MemberServiceTest.java에 다음을 추가해준 뒤 실행해보자

```java

(...)
import static org.junit.jupiter.api.Assertions.assertThrows;

(...)
    @Test
    @DisplayName("중복 회원 가입 테스트")
    public void saveDuplicationMemberTest(){
        Member member1 = createMember();
        Member member2 = createMember();
        memberService.saveMember(member1);
        
        Throwable e = assertThrows(IllegalStateException.class, ()->{
            memberService.saveMember(member2);
        });
        
        assertEquals("이미 가입된 회원입니다.", e.getMessage());
    }
```

우리가 예상한 예외가 발생하고, 테스트가 통과하는걸 확인 가능하다.
- 이제 회원 가입 로직을 완성했으므로 회원 가입을 위한 페이지를 만들어보자.
- Controller 패키지 아래에 MemberController 클래스를 만들자.

```java

import com.shop.dto.MemberFormDto;
import com.shop.service.MemberService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

@RequestMapping("/members")
@Controller
@RequiredArgsConstructor
public class MemberController {

    private final MemberService memberService;

    @GetMapping(value = "/new")
    public String memberForm(Model model){
        / 회원 가입 페이지로 이동할 수 있도록 MemberController 클래스에 메소드를 작성.
        model.addAttribute("memberFormDto", new MemberFormDto());
        return "member/memberForm";
    }
}
```

회원 가입 페이지도 3장 Thymeleaf에서 사용했던 부트스트랩을 사용하겠다.

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layouts/layout1}">

<!-- 사용자 CSS 추가 -->
<th:block layout:fragment="css">
    <style>
        .fieldError {
            color: #bd2130;
        }
    </style>
</th:block>

<!-- 사용자 스크립트 추가 -->
<th:block layout:fragment="script">

    <!--회원가입 시 실패했다면 에러 메시지를 경고창을 이용해서 보여준다.-->
    <script th:inline="javascript">
        $(document).ready(function(){
            var errorMessage = [[${errorMessage}]];
            if(errorMessage != null){
                alert(errorMessage);
            }
        });
    </script>

</th:block>

<div layout:fragment="content">

    <form action="/members/new" role="form" method="post"  th:object="${memberFormDto}">
        <div class="form-group">
            <label th:for="name">이름</label>
            <input type="text" th:field="*{name}" class="form-control" placeholder="이름을 입력해주세요">
            <p th:if="${#fields.hasErrors('name')}" th:errors="*{name}" class="fieldError">Incorrect data</p>
        </div>
        <div class="form-group">
            <label th:for="email">이메일주소</label>
            <input type="email" th:field="*{email}" class="form-control" placeholder="이메일을 입력해주세요">
            <p th:if="${#fields.hasErrors('email')}" th:errors="*{email}" class="fieldError">Incorrect data</p>
        </div>
        <div class="form-group">
            <label th:for="password">비밀번호</label>
            <input type="password" th:field="*{password}" class="form-control" placeholder="비밀번호 입력">
            <p th:if="${#fields.hasErrors('password')}" th:errors="*{password}" class="fieldError">Incorrect data</p>
        </div>
        <div class="form-group">
            <label th:for="address">주소</label>
            <input type="text" th:field="*{address}" class="form-control" placeholder="주소를 입력해주세요">
            <p th:if="${#fields.hasErrors('address')}" th:errors="*{address}" class="fieldError">Incorrect data</p>
        </div>
        <div style="text-align: center">
            <button type="submit" class="btn btn-primary" style="">Submit</button>
        </div>
        <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}">
        <!--스프링 시큐리티는 기본적으로 CSRF를 방어하기 위해 모든 POST 방식의 데이터 전송엔 CSRF 토큰값이 있어야한다.-->
    </form>

</div>

</html>
```

- 이제 controller 패키지에 MemberController 클래스를 수정해주자

```java
import com.shop.entity.Member;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.PostMapping;

@RequestMapping("/members")
@Controller
@RequiredArgsConstructor
public class MemberController {

    private final MemberService memberService;
    private final PasswordEncoder passwordEncoder;
    
    @GetMapping(value = "/new")
    public String memberForm(Model model){
        model.addAttribute("memberFormDto", new MemberFormDto());
        return "member/memberForm";
    }
    
    @PostMapping(value="/new")
    public String memberForm(MemberFormDto memberFormDto){
        
        Member member = Member.createMember(memberFormDto, passwordEncoder);
        memberService.saveMember(member);
        
        return "redirect:/";
    }
}
```

그리고 회원가입 후 메인페이지로 돌아갈 수 있도록 MainController.java 소스를 만들어주겠다.


```java
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class MainController {
    
    @GetMapping(value="/")
    public String main(){
        return "main";
    }
}
```

이제 resource/templates 폴더 아래에 main.html파일을 만들어주자
- 추후엔 메인페이지에 상품 목록이 뜨게 할것이다

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layouts/layout1}">

<div layout:fragment="content">
    <h1>메인페이지입니다.</h1>
</div>
```

이제 localhost/members/new 에 들어가보면 다음 화면이 뜨는걸 확인할 수 있다.


<img src="/assets/images/blog/shop3/new.png" class="img-responsive" alt="">

정보를 입력하고 회원가입을 누를시 정상적으로 메인페이지로 이동하게 된다.
- 다만 지금은 이름이나 비밀번호를 입력하지 않아도 정상적으로 저장이 된다.
- 회원 가입 페이지에서 서버로 넘어오는 값을 검증하기 위해서 pom.xml에 validation 종속성을 추가해주자

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```